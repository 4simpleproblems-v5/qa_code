<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Semaphore: iPhone Edition</title>
    <style>
        :root { --on: #ff0000; --off: #0a0000; --ui: #222; --text: #f5f5f5; }
        body {
            background-color: #000;
            color: var(--text);
            font-family: 'Courier New', monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-user-select: none; /* Prevent text selection on iOS */
        }

        /* NAVIGATION */
        .nav { display: flex; height: 50px; border-bottom: 1px solid #333; }
        .nav-item {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #111; cursor: pointer; font-weight: bold; border-right: 1px solid #333;
        }
        .nav-item.active { background: var(--on); color: #000; }

        .screen { display: none; flex: 1; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .screen.active { display: flex; }

        /* TRANSMITTER */
        #tx-target {
            width: 250px; height: 250px;
            background: var(--off);
            border: 4px solid #333;
            border-radius: 20px;
            margin-bottom: 20px;
            display: flex; align-items: center; justify-content: center;
            font-size: 5rem; font-weight: 900; color: #000;
        }
        .input-group { width: 90%; max-width: 400px; display: flex; gap: 10px; }
        input {
            flex: 1; background: #222; border: 1px solid #444; color: #fff;
            padding: 15px; font-family: monospace; border-radius: 8px;
            -webkit-appearance: none; /* iOS styling fix */
        }
        button.action-btn {
            background: var(--on); color: #000; border: none; font-weight: bold;
            padding: 0 20px; border-radius: 8px; cursor: pointer;
        }

        /* RECEIVER */
        #cam-wrapper {
            position: relative;
            width: 320px; height: 240px;
            background: #111; border: 2px solid #444;
            overflow: hidden; margin-bottom: 10px;
            border-radius: 10px;
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
            /* iOS Safari High Contrast Fix */
            filter: contrast(1.2) brightness(1.1); 
        }
        
        #reticle {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            transform: translate(-50%, -50%);
            border: 2px solid #0f0;
            /* Box shadow creates the dark overlay */
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.85); 
            z-index: 10;
        }

        #graph { width: 320px; height: 60px; background: #111; border: 1px solid #333; }
        
        #rx-output {
            margin-top: 15px; font-size: 1.2rem; min-height: 1.5rem;
            color: #0f0; text-shadow: 0 0 5px #0f0;
            max-width: 90%; word-break: break-all; text-align: center;
        }

        #link-btn {
            display: none; margin-top: 20px;
            background: #007AFF; color: white; padding: 15px 30px;
            border-radius: 30px; text-decoration: none; font-weight: bold;
            box-shadow: 0 0 15px #007AFF;
        }

        .status-pill {
            font-size: 0.8rem; color: #666; margin-top: 5px;
            background: #111; padding: 4px 10px; border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="nav">
        <div class="nav-item active" onclick="setMode('tx')">TRANSMIT</div>
        <div class="nav-item" onclick="setMode('rx')">RECEIVE</div>
    </div>

    <div id="tx-screen" class="screen active">
        <div class="status-pill">Brightness MUST be 100%</div>
        <div id="tx-target"></div>
        
        <div class="input-group">
            <input type="text" id="tx-input" placeholder="https://..." value="https://youtube.com">
            <button class="action-btn" onclick="transmit()">SEND</button>
        </div>
    </div>

    <div id="rx-screen" class="screen">
        <button id="start-cam-btn" class="action-btn" style="margin-bottom:20px;" onclick="startRx()">START BACK CAMERA</button>
        
        <div id="cam-wrapper">
            <video id="video" autoplay playsinline muted></video>
            <div id="reticle"></div>
        </div>
        
        <canvas id="graph" width="320" height="60"></canvas>
        <div id="rx-output">Ready</div>
        
        <a id="link-btn" href="#" target="_blank">OPEN LINK â†—</a>
        
        <div class="status-pill">Hold 2 inches from screen</div>
    </div>

    <script>
        // --- CONFIG ---
        const BIT_TIME = 80; // ~12 bits/sec

        // --- NAVIGATION ---
        function setMode(mode) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.getElementById(mode + '-screen').classList.add('active');
            document.querySelectorAll('.nav-item')[mode === 'tx' ? 0 : 1].classList.add('active');
        }

        // --- TRANSMITTER ---
        const target = document.getElementById('tx-target');
        
        async function transmit() {
            const rawText = document.getElementById('tx-input').value;
            const text = "\x02" + rawText + "\x03";
            
            // Header: Rapid pulses to wake up auto-exposure
            for(let i=0; i<6; i++) {
                flash(true); await wait(BIT_TIME);
                flash(false); await wait(BIT_TIME);
            }
            
            // Data
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                for (let bit = 7; bit >= 0; bit--) {
                    flash((charCode >> bit) & 1);
                    await wait(BIT_TIME);
                }
            }
            flash(false);
        }

        function flash(on) { target.style.backgroundColor = on ? "var(--on)" : "var(--off)"; }
        const wait = ms => new Promise(r => setTimeout(r, ms));


        // --- RECEIVER (IOS FIX) ---
        let rxRunning = false;
        const video = document.getElementById('video');
        const cvs = document.createElement('canvas');
        const ctx = cvs.getContext('2d', { willReadFrequently: true });
        
        const gCvs = document.getElementById('graph');
        const gCtx = gCvs.getContext('2d');
        const output = document.getElementById('rx-output');
        const linkBtn = document.getElementById('link-btn');

        async function startRx() {
            try {
                // IOS FIX: Simple constraints work best on iPhone SE
                // "environment" forces the back camera.
                const constraints = { 
                    audio: false,
                    video: { facingMode: "environment" } 
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // IOS FIX: Explicit play call is sometimes needed
                video.onloadedmetadata = () => {
                    video.play();
                };

                document.getElementById('start-cam-btn').style.display = 'none';
                rxRunning = true;
                processLoop();
            } catch(e) { 
                alert("Camera Error: " + e.message + "\nMake sure you allowed camera access in Safari settings."); 
            }
        }

        // --- DECODER LOGIC ---
        let lumaHistory = new Array(320).fill(0);
        let bitBuffer = 0;
        let bitCount = 0;
        let msgBuffer = "";
        let state = "SEARCH";
        let lastBitTime = 0;

        function processLoop() {
            if(!rxRunning) return;
            
            // 1. SAMPLE (Small center crop)
            cvs.width = 20; cvs.height = 20;
            // Draw center of video
            ctx.drawImage(video, video.videoWidth/2 - 10, video.videoHeight/2 - 10, 20, 20, 0, 0, 20, 20);
            const frame = ctx.getImageData(0,0,20,20).data;
            
            let sum = 0;
            for(let i=0; i<frame.length; i+=4) sum += frame[i]; // Read Red Channel
            const val = sum / (frame.length/4);

            // 2. GRAPH & THRESHOLD
            lumaHistory.push(val);
            lumaHistory.shift();
            drawGraph();

            const localAvg = lumaHistory.slice(-30).reduce((a,b)=>a+b,0)/30;
            // Adaptive Threshold: Signal must be 20 units brighter than the 1-second average
            const isHigh = val > (localAvg + 20); 

            const now = Date.now();

            // 3. STATE MACHINE
            if (state === "SEARCH") {
                if (isHigh) {
                    state = "READ";
                    // Sync: Assume we caught the rising edge, wait 0.5 bits to get to center
                    lastBitTime = now + (BIT_TIME/2);
                    msgBuffer = "";
                    bitBuffer = 0;
                    bitCount = 0;
                }
            }
            else if (state === "READ") {
                if (now >= lastBitTime + BIT_TIME) {
                    lastBitTime += BIT_TIME;
                    
                    bitBuffer = (bitBuffer << 1) | (isHigh ? 1 : 0);
                    bitCount++;

                    if (bitCount === 8) {
                        const char = String.fromCharCode(bitBuffer);
                        
                        if (char === "\x02") {
                            msgBuffer = "";
                            output.innerText = "Receiving...";
                            output.style.color = "#FFD60A";
                        } 
                        else if (char === "\x03") {
                            finishReceive();
                        } 
                        else {
                            msgBuffer += char;
                            output.innerText = msgBuffer;
                        }
                        bitBuffer = 0; bitCount = 0;
                    }
                }
                
                // Timeout (2 sec silence)
                if (now > lastBitTime + 2000) {
                    state = "SEARCH";
                    output.innerText = "Signal Lost";
                    output.style.color = "#FF453A";
                }
            }
            requestAnimationFrame(processLoop);
        }

        function finishReceive() {
            state = "SEARCH";
            output.innerText = msgBuffer;
            output.style.color = "#0f0";
            
            if (msgBuffer.startsWith("http")) {
                linkBtn.href = msgBuffer;
                linkBtn.style.display = "inline-block";
                linkBtn.innerText = "OPEN: " + msgBuffer.substring(0, 15) + "...";
            }
        }

        function drawGraph() {
            gCtx.fillStyle = "#000";
            gCtx.fillRect(0,0,320,60);
            gCtx.beginPath();
            gCtx.strokeStyle = "rgba(255, 0, 0, 0.8)";
            gCtx.lineWidth = 2;
            for(let i=0; i<320; i++) {
                const y = 60 - (lumaHistory[i] / 255 * 60);
                if(i==0) gCtx.moveTo(i,y); else gCtx.lineTo(i,y);
            }
            gCtx.stroke();
        }
    </script>
</body>
</html>
