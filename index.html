<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project QA Code (Optimized)</title>
    <style>
        :root { --primary: #0A84FF; --bg: #121212; --text: #E0E0E0; --card: #1E1E1E; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            text-align: center;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s ease;
        }

        h1 { margin-bottom: 5px; font-size: 1.5rem; color: var(--primary); }
        p { margin-top: 0; color: #888; font-size: 0.9rem; }

        .container {
            background: var(--card);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 100%;
            margin-bottom: 20px;
            border: 1px solid #333;
        }

        .section-title {
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        /* Controls */
        input[type="color"] { border: none; width: 80px; height: 50px; cursor: pointer; background: none; }
        
        .vol-control { margin: 15px 0; display: flex; align-items: center; justify-content: space-between; font-size: 0.8rem; color: #aaa; }
        input[type="range"] { flex-grow: 1; margin: 0 10px; accent-color: var(--primary); }

        button {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 10px;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            background-color: var(--primary);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:disabled { background-color: #333; color: #777; cursor: not-allowed; }

        #rx-status {
            font-family: monospace;
            background: #000;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #00FF00;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>

    <h1>Project QA Code v2</h1>
    <p>High-Fidelity Ultrasonic Transfer</p>

    <div class="container">
        <div class="section-title">Transmitter</div>
        <input type="color" id="colorPicker" value="#FFFFFF">
        
        <div class="vol-control">
            <span>Vol:</span>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.2">
            <span id="volLabel">20%</span>
        </div>

        <button id="broadcastBtn">Broadcast Data</button>
    </div>

    <div class="container">
        <div class="section-title">Receiver</div>
        <button id="listenBtn">Start Receiver</button>
        <div id="rx-status">Waiting to start...</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // Range: 17.2kHz -> 19.2kHz (2kHz Bandwidth)
        // This is slightly lower than before to ensure the iPhone mic picks it up clearly,
        // but high enough to be mostly inaudible.
        const FREQ_MIN = 17200; 
        const FREQ_MAX = 19200; 
        const FREQ_SYNC = 16500; // Distinct header tone
        
        // Timings (Slightly slower for robustness)
        const T_SYNC = 0.8;
        const T_DATA = 1.0; 
        const T_GAP = 0.2; 

        // --- UTILITIES ---
        const valToFreq = (val) => FREQ_MIN + (val * ((FREQ_MAX - FREQ_MIN) / 255));
        
        const freqToVal = (freq) => {
            if (freq < FREQ_MIN) freq = FREQ_MIN;
            if (freq > FREQ_MAX) freq = FREQ_MAX;
            return Math.round((freq - FREQ_MIN) * (255 / (FREQ_MAX - FREQ_MIN)));
        };

        const hexToRgb = (hex) => {
            const bi = parseInt(hex.substring(1), 16);
            return [(bi >> 16) & 255, (bi >> 8) & 255, bi & 255];
        };

        // --- TRANSMITTER ---
        let audioCtxTx;
        const btnTx = document.getElementById('broadcastBtn');
        const volSlider = document.getElementById('volumeSlider');
        const volLabel = document.getElementById('volLabel');

        volSlider.addEventListener('input', (e) => volLabel.innerText = Math.round(e.target.value * 100) + "%");

        btnTx.addEventListener('click', () => {
            if (!audioCtxTx) audioCtxTx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtxTx.state === 'suspended') audioCtxTx.resume();

            const rgb = hexToRgb(document.getElementById('colorPicker').value);
            const vol = parseFloat(volSlider.value);
            
            btnTx.disabled = true;
            btnTx.innerText = "Sending...";

            const t0 = audioCtxTx.currentTime + 0.1;
            
            // Schedule Tones
            // 1. Sync
            playTone(FREQ_SYNC, t0, T_SYNC, vol);
            
            // 2. Data (R, G, B)
            let curTime = t0 + T_SYNC + T_GAP;
            rgb.forEach((val, i) => {
                playTone(valToFreq(val), curTime, T_DATA, vol);
                curTime += T_DATA + T_GAP;
            });

            // Reset UI
            setTimeout(() => {
                btnTx.disabled = false;
                btnTx.innerText = "Broadcast Data";
            }, (curTime - t0) * 1000 + 200);
        });

        function playTone(freq, t, dur, vol) {
            const osc = audioCtxTx.createOscillator();
            const gain = audioCtxTx.createGain();
            osc.frequency.value = freq;
            osc.type = 'sine';
            
            // Ramp gain to avoid "pop" sounds
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(vol, t + 0.1);
            gain.gain.setValueAtTime(vol, t + dur - 0.1);
            gain.gain.linearRampToValueAtTime(0, t + dur);

            osc.connect(gain).connect(audioCtxTx.destination);
            osc.start(t);
            osc.stop(t + dur);
        }

        // --- RECEIVER ---
        let audioCtxRx, analyser, mic;
        let isRunning = false;
        let rxState = 'IDLE'; 
        const status = document.getElementById('rx-status');
        const btnRx = document.getElementById('listenBtn');

        btnRx.addEventListener('click', async () => {
            try {
                audioCtxRx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtxRx.createAnalyser();
                // Higher FFT size = Better frequency resolution (Essential for this range)
                analyser.fftSize = 8192; 
                analyser.smoothingTimeConstant = 0; // Instant reactions

                // Disable iPhone audio processing filters
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });
                
                mic = audioCtxRx.createMediaStreamSource(stream);
                mic.connect(analyser);
                
                isRunning = true;
                btnRx.style.display = 'none';
                status.innerText = "Listening...";
                loop();
            } catch(e) { alert(e.message); }
        });

        function getDominantFreq() {
            const bufferLen = analyser.frequencyBinCount;
            const data = new Uint8Array(bufferLen);
            analyser.getByteFrequencyData(data);

            let maxVal = 0; 
            let maxIdx = 0;
            // Only scan relevant high-frequency bins to save CPU/Errors
            // 16000Hz approx bin index = 16000 / (44100/8192) ~= 2972
            const startBin = Math.floor(15000 / (audioCtxRx.sampleRate / analyser.fftSize));
            
            for(let i = startBin; i < bufferLen; i++) {
                if(data[i] > maxVal) {
                    maxVal = data[i];
                    maxIdx = i;
                }
            }

            if(maxVal < 30) return 0; // Silence threshold
            return maxIdx * (audioCtxRx.sampleRate / analyser.fftSize);
        }

        function loop() {
            if(!isRunning) return;
            requestAnimationFrame(loop);

            const freq = getDominantFreq();
            
            if(rxState === 'IDLE') {
                // Check for Sync Tone (16.5k +/- 150Hz)
                if(Math.abs(freq - FREQ_SYNC) < 150) {
                    rxState = 'SYNCED';
                    status.innerText = "Sync Detected! Decoding...";
                    startSamplingSequence();
                }
            }
        }

        function startSamplingSequence() {
            const colors = [];
            // We need to sample roughly in the MIDDLE of each tone pulse.
            // Sync(0.8) + Gap(0.2) + Half_Tone(0.5) = 1.5s delay for first read center
            
            let delay = (T_SYNC + T_GAP + (T_DATA/2)) * 1000;
            const interval = (T_DATA + T_GAP) * 1000;

            // Schedule 3 samplers
            setTimeout(() => sampleBurst(0, colors), delay);
            setTimeout(() => sampleBurst(1, colors), delay + interval);
            setTimeout(() => sampleBurst(2, colors), delay + interval * 2);
        }

        // Takes multiple samples over 200ms and averages them for accuracy
        function sampleBurst(index, resultArr) {
            let samples = [];
            let count = 0;
            const labels = ['Red', 'Green', 'Blue'];
            
            status.innerText = `Sampling ${labels[index]}...`;

            // Rapid fire 5 samples every 40ms
            const burstInterval = setInterval(() => {
                const f = getDominantFreq();
                if(f > FREQ_MIN - 200 && f < FREQ_MAX + 200) {
                    samples.push(f);
                }
                count++;
                
                if(count >= 5) {
                    clearInterval(burstInterval);
                    processBurst(samples, index, resultArr);
                }
            }, 40);
        }

        function processBurst(samples, index, resultArr) {
            if(samples.length === 0) {
                // If we missed it (silence), assume 0 or repeat previous? Assume 0.
                resultArr[index] = 0;
            } else {
                // Average the samples
                const avgFreq = samples.reduce((a,b)=>a+b, 0) / samples.length;
                resultArr[index] = freqToVal(avgFreq);
            }

            // If we have all 3
            if(index === 2) {
                finish(resultArr);
            }
        }

        function finish(rgb) {
            const [r,g,b] = rgb;
            const col = `rgb(${r},${g},${b})`;
            
            document.body.style.backgroundColor = col;
            
            // Contrast text
            const lum = 0.2126*r + 0.7152*g + 0.0722*b;
            document.body.style.color = lum > 128 ? '#000' : '#FFF';
            
            status.innerText = `Received: ${col}`;
            status.style.color = lum > 128 ? '#000' : '#00FF00';

            setTimeout(() => {
                rxState = 'IDLE';
                status.innerText = "Ready for next...";
            }, 1000);
        }
    </script>
</body>
</html>
