<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper-Grid v2: Atomic</title>
    <style>
        :root { --bg: #000; --text: #0f0; --accent: #00ff00; --err: #ff0000; }
        body {
            background-color: var(--bg); color: var(--text);
            font-family: 'Courier New', monospace; margin: 0;
            display: flex; flex-direction: column; height: 100vh;
            overflow: hidden; -webkit-user-select: none;
        }

        /* NAV */
        .nav { display: flex; height: 50px; border-bottom: 1px solid #333; }
        .nav-item {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #111; cursor: pointer; font-weight: bold; border-right: 1px solid #333; color: #666;
        }
        .nav-item.active { background: #112211; color: var(--accent); border-bottom: 2px solid var(--accent); }

        .view { display: none; flex: 1; flex-direction: column; align-items: center; padding: 10px; }
        .view.active { display: flex; }

        /* TRANSMITTER */
        #grid-wrapper {
            position: relative; width: 300px; height: 300px; margin-bottom: 20px;
            border: 4px solid #fff; padding: 2px;
        }
        #tx-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100%; height: 100%; gap: 2px;
        }
        .cell {
            background: #000; border: 1px solid #222;
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem; color: #444; font-weight: bold;
        }
        .cell.on { background: #FFF; color: #000; }
        
        #c0::after { content: "CLK"; font-size: 0.6rem; }

        .controls { width: 100%; max-width: 300px; display: flex; flex-direction: column; gap: 10px; }
        input[type="text"] { 
            padding: 15px; background: #111; border: 1px solid #333; color: #fff; 
            text-align: center; width: 100%; font-family: monospace; font-size: 1.2rem;
        }
        button { 
            padding: 15px; border: none; border-radius: 4px; font-weight: bold; 
            cursor: pointer; background: var(--accent); color: #000; font-size: 1rem;
        }

        /* RECEIVER */
        #cam-container {
            position: relative; width: 300px; height: 300px;
            background: #000; border: 2px solid #555; overflow: hidden; margin-bottom: 10px;
        }
        video { width: 100%; height: 100%; object-fit: cover; filter: grayscale(1) contrast(1.5) brightness(1.2); }
        
        /* The Mesh Overlay */
        #overlay { position: absolute; top:0; left:0; width:100%; height:100%; }

        /* Realtime Binary View */
        #binary-view {
            display: grid; grid-template-columns: repeat(4, 1fr); 
            width: 100px; height: 100px; border: 1px solid #333; margin-bottom: 10px;
            gap: 1px;
        }
        .bin-cell { background: #111; }
        .bin-cell.on { background: var(--accent); }

        #rx-log { 
            width: 300px; height: 60px; background: #111; border: 1px solid #333; 
            padding: 10px; color: var(--accent); font-size: 1.2rem; overflow-wrap: break-word;
        }
        
        .slider-row { width: 300px; display: flex; align-items: center; justify-content: space-between; font-size: 0.7rem; color: #888; margin-bottom: 5px; }
        input[type="range"] { flex: 1; margin: 0 10px; accent-color: var(--accent); }

    </style>
</head>
<body>

    <div class="nav">
        <div class="nav-item active" onclick="setView('tx')">SENDER</div>
        <div class="nav-item" onclick="setView('rx')">RECEIVER</div>
    </div>

    <div id="tx-view" class="view active">
        <div id="grid-wrapper">
            <div id="tx-grid"></div>
        </div>

        <div class="controls">
            <input type="text" id="tx-input" value="HYPER-GRID" placeholder="Message">
            <button id="tx-btn" onclick="transmit()">SEND (Atomic Mode)</button>
        </div>
        <div style="font-size:0.7rem; color:#666; margin-top:10px; text-align:center;">
            1 Letter Per Frame. <br>Impossible to desync.
        </div>
    </div>

    <div id="rx-view" class="view">
        <button id="cam-btn" onclick="startRx()" style="width:300px; margin-bottom:15px;">START CAMERA</button>
        
        <div id="cam-container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay" width="300" height="300"></canvas>
        </div>
        
        <div style="display:flex; width:300px; gap:10px; align-items:center;">
            <div id="binary-view">
                </div>
            <div style="flex:1;">
                <div class="slider-row">
                    <span>ZOOM</span>
                    <input type="range" id="inset-slider" min="0" max="120" value="40">
                </div>
                <div id="rx-log"></div>
            </div>
        </div>

        <div style="width:300px; display:flex; justify-content:space-between; font-size:0.8rem; color:#888; margin-top:5px;">
            <span id="state-lbl">ALIGN GRID</span>
            <span>Use Zoom Slider</span>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const FRAME_MS = 400; // 400ms per character
        const PILOT_MS = 2000;

        // Generate Grids
        const txGrid = document.getElementById('tx-grid');
        const binView = document.getElementById('binary-view');
        const txCells = [];
        const binCells = [];

        for(let i=0; i<16; i++) {
            // Main TX cells
            let d = document.createElement('div');
            d.id = 'c'+i; d.className = 'cell';
            if(i===0) d.innerText = "CLK";
            else if(i<=8) d.innerText = "B"+(8-i); // Bits
            txGrid.appendChild(d);
            txCells.push(d);

            // Mini RX cells
            let b = document.createElement('div');
            b.className = 'bin-cell';
            binView.appendChild(b);
            binCells.push(b);
        }

        function setView(v) {
            document.querySelectorAll('.view').forEach(e => e.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(e => e.classList.remove('active'));
            document.getElementById(v+'-view').classList.add('active');
            event.target.classList.add('active');
        }

        // --- TRANSMITTER ---
        async function transmit() {
            const text = document.getElementById('tx-input').value;
            const btn = document.getElementById('tx-btn');
            btn.disabled = true;

            // 1. PILOT (All White)
            btn.innerText = "PILOT...";
            setAll(true);
            await wait(PILOT_MS);

            // 2. SYNC (All Black)
            btn.innerText = "SYNC...";
            setAll(false);
            await wait(FRAME_MS * 2);

            // 3. DATA (1 Char per Frame)
            btn.innerText = "TRANSMITTING...";
            let clk = false;

            for(let i=0; i<text.length; i++) {
                clk = !clk; // Toggle Clock (Cell 0)
                setCell(0, clk);

                // Get ASCII bits (8 bits)
                // We send MSB at Cell 1, LSB at Cell 8
                const charCode = text.charCodeAt(i);
                
                for(let b=0; b<8; b++) {
                    // Check bit (7-b because we want high bits first)
                    const on = (charCode >> (7-b)) & 1;
                    setCell(b+1, on);
                    
                    // Inverted copy in bottom half (redundancy visual)
                    // If we wanted error check we could use this, but for now just mirror or leave black
                    // Let's leave black to keep contrast high
                }

                await wait(FRAME_MS);
            }

            setAll(false);
            btn.innerText = "SEND (Atomic)";
            btn.disabled = false;
        }

        function setCell(idx, on) { txCells[idx].className = on ? 'cell on' : 'cell'; }
        function setAll(on) { txCells.forEach(c => c.className = on ? 'cell on' : 'cell'); }
        const wait = ms => new Promise(r => setTimeout(r, ms));


        // --- RECEIVER ---
        let rxRunning = false;
        const vid = document.getElementById('video');
        const overlay = document.getElementById('overlay');
        const oCtx = overlay.getContext('2d');
        const log = document.getElementById('rx-log');
        const stateLbl = document.getElementById('state-lbl');
        
        // Processing Canvas
        const cvs = document.createElement('canvas'); 
        const ctx = cvs.getContext('2d', { willReadFrequently: true });

        // Logic
        let lastClk = -1;
        let state = "SEARCH";
        let gridInset = 40;

        document.getElementById('inset-slider').addEventListener('input', (e) => {
            gridInset = parseInt(e.target.value);
        });

        async function startRx() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                vid.srcObject = stream;
                vid.onloadedmetadata = () => vid.play();
                document.getElementById('cam-btn').style.display = 'none';
                rxRunning = true;
                loop();
            } catch(e) { alert("Cam Error: "+e); }
        }

        function loop() {
            if(!rxRunning) return;

            // 1. Snapshot
            cvs.width = 300; cvs.height = 300;
            ctx.drawImage(vid, 0, 0, 300, 300);
            const frame = ctx.getImageData(0,0,300,300).data;

            // 2. Read 4x4 Grid
            const size = 300 - (gridInset * 2);
            const cellSize = size / 4;
            const start = gridInset;
            const readings = []; 
            
            oCtx.clearRect(0,0,300,300);
            oCtx.strokeStyle = "rgba(0, 255, 0, 0.5)";
            oCtx.lineWidth = 1;
            oCtx.beginPath();

            for(let i=0; i<16; i++) {
                const x = i % 4;
                const y = Math.floor(i / 4);
                
                const cx = start + (x * cellSize) + (cellSize/2);
                const cy = start + (y * cellSize) + (cellSize/2);
                
                // Draw Grid
                oCtx.rect(start + x*cellSize, start + y*cellSize, cellSize, cellSize);

                // Sample Luma
                const luma = getAvgLuma(frame, cx, cy);
                const on = luma > 100; // Threshold
                readings.push(on ? 1 : 0);

                // Update Mini-View
                binCells[i].className = on ? 'bin-cell on' : 'bin-cell';
            }
            oCtx.stroke();

            // 3. Logic
            const clk = readings[0]; 

            if(state === "SEARCH") {
                const sum = readings.reduce((a,b)=>a+b,0);
                // Wait for PILOT (All 16 on)
                if(sum >= 15) state = "PILOT";
            }
            else if(state === "PILOT") {
                stateLbl.innerText = "LOCKED - WAIT";
                stateLbl.style.color = "#FFF";
                const sum = readings.reduce((a,b)=>a+b,0);
                // Wait for Drop (All 0)
                if(sum <= 1) {
                    state = "READ";
                    lastClk = 0; 
                    log.innerText = "";
                    stateLbl.innerText = "RECEIVING";
                    stateLbl.style.color = "#0f0";
                }
            }
            else if(state === "READ") {
                // Wait for Clock Toggle
                if(clk !== lastClk) {
                    lastClk = clk;
                    
                    // Decode Atomic Frame (Cells 1-8 are Bits 7-0)
                    let byteVal = 0;
                    for(let b=0; b<8; b++) {
                        if(readings[b+1]) {
                            byteVal |= (1 << (7-b));
                        }
                    }

                    // Print Char
                    if(byteVal >= 32 && byteVal <= 126) {
                        const char = String.fromCharCode(byteVal);
                        log.innerText += char;
                        log.scrollTop = log.scrollHeight;
                    }
                }
            }

            requestAnimationFrame(loop);
        }

        function getAvgLuma(data, x, y) {
            let sum = 0; let c = 0;
            x = Math.floor(x); y = Math.floor(y);
            for(let dy=-3; dy<=3; dy++) {
                for(let dx=-3; dx<=3; dx++) {
                    const i = ((y+dy)*300 + (x+dx)) * 4;
                    if(i>=0 && i<data.length) {
                        sum += (data[i] + data[i+1] + data[i+2]) / 3;
                        c++;
                    }
                }
            }
            return sum/c;
        }

    </script>
</body>
</html>
