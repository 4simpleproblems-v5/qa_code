<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mag-Net v2: Robust</title>
    <style>
        :root { --bg: #000; --on: #ff00ff; --off: #222; --text: #fff; }
        body {
            background-color: var(--bg); color: var(--text);
            font-family: 'Courier New', monospace; margin: 0;
            display: flex; flex-direction: column; height: 100vh;
            overflow: hidden; -webkit-user-select: none;
        }

        /* NAV */
        .nav { display: flex; height: 60px; border-bottom: 1px solid #333; }
        .nav-item {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #111; cursor: pointer; font-weight: bold; border-right: 1px solid #333; color: #666;
        }
        .nav-item.active { background: #220022; color: var(--on); border-bottom: 3px solid var(--on); }

        .view { display: none; flex: 1; flex-direction: column; align-items: center; padding: 20px; }
        .view.active { display: flex; }

        /* METER */
        #meter-container {
            width: 100%; max-width: 400px; height: 150px;
            background: #111; border: 2px solid #333;
            position: relative; margin-bottom: 10px;
        }
        canvas { width: 100%; height: 100%; display: block; }
        
        #threshold-line {
            position: absolute; width: 100%; height: 2px; background: #fff; top: 70%; opacity: 0.5;
            pointer-events: none;
        }

        /* CONTROLS */
        button {
            padding: 20px; font-size: 1.2rem; font-weight: bold;
            background: var(--on); color: #000; border: none; border-radius: 4px;
            cursor: pointer; width: 100%; max-width: 300px; margin-bottom: 10px;
        }
        button.secondary { background: #444; color: #fff; }
        button:disabled { background: #333; color: #555; cursor: not-allowed; }

        input {
            padding: 15px; background: #222; border: 1px solid #444; color: #fff;
            text-align: center; width: 100%; max-width: 300px; 
            font-family: monospace; font-size: 1.2rem; margin-bottom: 20px;
        }

        .log {
            font-size: 1.5rem; letter-spacing: 3px; color: var(--on);
            margin-top: 10px; min-height: 40px; border-bottom: 1px solid #333; width: 100%; text-align: center;
        }
        .debug { font-size: 0.8rem; color: #888; margin-top: 5px; }

    </style>
</head>
<body>

    <div class="nav">
        <div class="nav-item active" onclick="setView('tx')">SENDER</div>
        <div class="nav-item" onclick="setView('rx')">RECEIVER</div>
    </div>

    <div id="tx-view" class="view active">
        <h2 style="color:var(--on)">MAGNETIC COIL</h2>
        <div class="debug" style="margin-bottom:20px">Vol: MAX | Placement: CRITICAL</div>

        <input type="text" id="tx-input" value="A" placeholder="MSG">
        
        <button class="secondary" onmousedown="startTest(true)" onmouseup="startTest(false)" ontouchstart="startTest(true)" ontouchend="startTest(false)">HOLD FOR TEST SIGNAL</button>
        <div class="debug" style="margin-bottom:20px">Use this to find sweet spot on Receiver</div>
        
        <button id="tx-btn" onclick="transmit()">SEND DATA</button>
        <div id="tx-status" class="debug">Ready</div>
    </div>

    <div id="rx-view" class="view">
        <h2 style="color:var(--on)">FLUX DETECTOR</h2>
        <button id="perm-btn" onclick="reqPerms()">CALIBRATE SENSORS</button>
        
        <div id="meter-container">
            <canvas id="scope"></canvas>
            <div id="threshold-line"></div>
        </div>
        <div class="debug">CHAOS METER (Must hit Red Line)</div>

        <div id="rx-log" class="log"></div>
        <div id="rx-debug" class="debug">Waiting...</div>
    </div>

    <script>
        // --- CONFIG ---
        const BIT_TIME = 600; // Slower is safer
        const THRESHOLD = 3.0; // How much "chaos" is needed to register a 1

        function setView(v) {
            document.querySelectorAll('.view').forEach(e => e.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(e => e.classList.remove('active'));
            document.getElementById(v+'-view').classList.add('active');
            event.target.classList.add('active');
        }

        // --- TRANSMITTER (Audio) ---
        const wait = ms => new Promise(r => setTimeout(r, ms));
        let audioCtx;
        
        // Brown Noise Generator (Creating Magnetic Chaos)
        function createNoiseBuffer() {
            if(!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2; // 2 seconds
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                lastOut = (lastOut + (0.02 * white)) / 1.02;
                data[i] = lastOut * 3.5; // Amplify
            }
            return buffer;
        }

        let noiseNode = null;

        async function setMagneticField(on) {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if(audioCtx.state === 'suspended') await audioCtx.resume();

            if(on) {
                if(noiseNode) return;
                const buffer = createNoiseBuffer();
                noiseNode = audioCtx.createBufferSource();
                noiseNode.buffer = buffer;
                noiseNode.loop = true;
                noiseNode.connect(audioCtx.destination);
                noiseNode.start();
            } else {
                if(noiseNode) {
                    noiseNode.stop();
                    noiseNode.disconnect();
                    noiseNode = null;
                }
            }
        }

        function startTest(on) {
            setMagneticField(on);
            document.getElementById('tx-status').innerText = on ? "GENERATING FIELD..." : "Ready";
        }

        async function transmit() {
            const text = document.getElementById('tx-input').value.toUpperCase();
            const btn = document.getElementById('tx-btn');
            const stat = document.getElementById('tx-status');
            btn.disabled = true;

            // Encode Binary
            let bits = "";
            for(let i=0; i<text.length; i++) {
                bits += text.charCodeAt(i).toString(2).padStart(8, "0");
            }

            // Sync Sequence
            stat.innerText = "SYNC...";
            await setMagneticField(true); await wait(BIT_TIME*2);
            await setMagneticField(false); await wait(BIT_TIME);

            // Data
            for(let i=0; i<bits.length; i++) {
                const bit = bits[i];
                stat.innerText = `Sending: ${bit} (${i+1}/${bits.length})`;
                
                if(bit === '1') await setMagneticField(true);
                else await setMagneticField(false);
                
                await wait(BIT_TIME);
            }

            await setMagneticField(false);
            stat.innerText = "Done";
            btn.disabled = false;
        }


        // --- RECEIVER (Compass) ---
        const canvas = document.getElementById('scope');
        const ctx = canvas.getContext('2d');
        const log = document.getElementById('rx-log');
        const dbg = document.getElementById('rx-debug');

        let isReading = false;
        let lastAlpha = 0;
        let chaosLevel = 0;
        let history = new Array(100).fill(0);
        let bitBuffer = "";
        let isReceiving = false;

        function reqPerms() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(r => { if(r=='granted') startRx(); })
                    .catch(alert);
            } else { startRx(); }
        }

        function startRx() {
            document.getElementById('perm-btn').style.display = 'none';
            isReading = true;
            window.addEventListener('deviceorientation', handleMotion);
            draw();
            setInterval(decodeLoop, BIT_TIME);
        }

        function handleMotion(e) {
            if(e.alpha === null) return;
            
            // Calculate derivative (Rate of Change)
            // If magnet is ON (Brown Noise), this value spikes wildly
            const delta = Math.abs(e.alpha - lastAlpha);
            lastAlpha = e.alpha;

            // Simple Low-Pass Filter to smooth visual, but keep magnitude
            // We specifically look for "unnatural" jumps > 0.5 deg
            if(delta > 0.5 && delta < 50) { // <50 filters out rotation wraparound (360->0)
                chaosLevel = (chaosLevel * 0.9) + (delta * 0.1);
            } else {
                chaosLevel = chaosLevel * 0.9;
            }
        }

        function draw() {
            if(!isReading) return;
            
            // Auto-size
            if(canvas.width !== canvas.parentElement.offsetWidth) {
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
            }

            // Clear
            ctx.fillStyle = "#000";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // Draw History
            history.push(chaosLevel);
            history.shift();

            ctx.beginPath();
            ctx.strokeStyle = "#ff00ff";
            ctx.lineWidth = 2;
            const step = canvas.width / history.length;
            
            for(let i=0; i<history.length; i++) {
                const h = history[i];
                // Scale: Threshold is approx 30% height
                const y = canvas.height - (h * 10);
                if(i===0) ctx.moveTo(0, y);
                else ctx.lineTo(i*step, y);
            }
            ctx.stroke();

            // Threshold Visual
            const tY = canvas.height - (THRESHOLD * 10);
            ctx.strokeStyle = "#fff";
            ctx.beginPath(); 
            ctx.moveTo(0, tY); ctx.lineTo(canvas.width, tY); 
            ctx.stroke();

            requestAnimationFrame(draw);
        }

        // Logic Loop (Runs every BIT_TIME)
        function decodeLoop() {
            if(!isReading) return;

            // Determine Bit
            const bit = chaosLevel > THRESHOLD ? "1" : "0";
            
            // Update UI
            dbg.innerText = `Chaos: ${chaosLevel.toFixed(2)} | Bit: ${bit}`;
            dbg.style.color = bit === "1" ? "#ff00ff" : "#555";

            // If high chaos detected for a while, assume sync start
            if(!isReceiving) {
                if(bit === "1") {
                    // Start of transmission (maybe)
                    isReceiving = true;
                    bitBuffer = "";
                    log.innerText = ""; 
                }
            } else {
                // We are receiving
                bitBuffer += bit;
                
                // Try decoding byte
                if(bitBuffer.length >= 8) {
                    const byte = bitBuffer.substring(0, 8);
                    const charCode = parseInt(byte, 2);
                    
                    // Simple filter for ASCII text
                    if(charCode >= 32 && charCode <= 126) {
                        log.innerText += String.fromCharCode(charCode);
                    }
                    
                    bitBuffer = bitBuffer.substring(8);
                }
            }
        }
    </script>
</body>
</html>
