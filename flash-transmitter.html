<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Semaphore: Stable</title>
    <style>
        :root { --on: #ffffff; --off: #000000; --text: #f5f5f5; }
        body {
            background-color: #111;
            color: var(--text);
            font-family: 'Courier New', monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-user-select: none;
        }

        /* TABS */
        .nav { display: flex; height: 60px; border-bottom: 1px solid #333; }
        .nav-item {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #1a1a1a; cursor: pointer; font-weight: bold; font-size: 1.1rem;
        }
        .nav-item.active { background: #333; color: #fff; border-bottom: 4px solid #fff; }

        .screen { display: none; flex: 1; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        .screen.active { display: flex; }

        /* TRANSMITTER */
        #tx-box {
            width: 250px; height: 250px;
            background: #000;
            border: 4px solid #444;
            margin-bottom: 30px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: bold; color: #000;
            text-align: center;
        }
        .tx-controls { width: 100%; max-width: 400px; display: flex; gap: 10px; }
        input {
            flex: 1; padding: 15px; font-family: monospace; font-size: 1rem;
            background: #222; border: 1px solid #444; color: #fff; border-radius: 8px;
        }
        button.send-btn {
            padding: 0 25px; background: #fff; color: #000; border: none;
            font-weight: bold; border-radius: 8px; cursor: pointer;
        }

        /* RECEIVER */
        #cam-container {
            position: relative; width: 300px; height: 200px;
            background: #000; border: 2px solid #555; overflow: hidden;
            margin-bottom: 15px;
        }
        video { width: 100%; height: 100%; object-fit: cover; filter: contrast(1.2) grayscale(1); }
        
        #debug-graph { width: 300px; height: 80px; background: #000; border: 1px solid #333; }
        
        .status-row { display: flex; justify-content: space-between; width: 300px; font-size: 0.8rem; color: #888; margin-top: 5px; }
        
        #rx-msg {
            margin-top: 15px; font-size: 1.2rem; color: #0f0; min-height: 1.5rem;
            text-shadow: 0 0 8px rgba(0,255,0,0.5); word-break: break-all;
        }
        
        #binary-debug { font-size: 0.7rem; color: #444; margin-top: 5px; height: 1rem; }
        
        #link-btn {
            display: none; margin-top: 20px; text-decoration: none;
            background: #007AFF; color: #fff; padding: 12px 24px; border-radius: 20px;
        }

    </style>
</head>
<body>

    <div class="nav">
        <div class="nav-item active" onclick="setTab('tx')">SEND</div>
        <div class="nav-item" onclick="setTab('rx')">RECEIVE</div>
    </div>

    <div id="tx-screen" class="screen active">
        <div id="tx-box">READY</div>
        <div class="tx-controls">
            <input type="text" id="msg-input" placeholder="https://..." value="HELLO">
            <button class="send-btn" onclick="startTransmission()">GO</button>
        </div>
        <p style="font-size: 0.8rem; color: #666; margin-top: 20px;">
            1. Set Laptop Brightness to 100%<br>
            2. Receiver must see the Box perfectly
        </p>
    </div>

    <div id="rx-screen" class="screen">
        <button id="cam-btn" class="send-btn" onclick="startCamera()">Start Camera</button>
        
        <div id="cam-container">
            <video id="video" autoplay playsinline muted></video>
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:40px; height:40px; border:2px solid #0f0; box-shadow: 0 0 0 100px rgba(0,0,0,0.8);"></div>
        </div>

        <canvas id="debug-graph" width="300" height="80"></canvas>
        
        <div class="status-row">
            <span id="state-lbl">STATE: IDLE</span>
            <span id="thresh-lbl">THR: 0</span>
        </div>

        <div id="rx-msg">Waiting...</div>
        <div id="binary-debug"></div>
        <a id="link-btn" href="#" target="_blank">OPEN LINK</a>
    </div>

    <script>
        // --- CONFIGURATION ---
        const BIT_TIME = 200; // 200ms = 5 bits/sec (Very Safe Speed)
        const PILOT_TIME = 1500; // 1.5s of solid white to lock sync

        // --- TABS ---
        function setTab(t) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.getElementById(t+'-screen').classList.add('active');
            event.target.classList.add('active');
        }

        // --- TRANSMITTER LOGIC ---
        const box = document.getElementById('tx-box');
        
        async function startTransmission() {
            const raw = document.getElementById('msg-input').value;
            // Packet: STX (0x02) + Text + ETX (0x03)
            const text = "\x02" + raw + "\x03";
            
            // 1. PILOT TONE (Solid White)
            // This tells the receiver "Get ready, calibrate your white level now"
            box.innerText = "PILOT...";
            box.style.background = "#FFF"; 
            await sleep(PILOT_TIME);

            // 2. START EDGE (Drop to Black)
            // This sharp drop triggers the receiver to start reading data
            box.innerText = "SYNC!";
            box.style.background = "#000";
            await sleep(BIT_TIME);

            // 3. DATA STREAM
            box.innerText = "SENDING";
            for(let i=0; i<text.length; i++) {
                const char = text.charCodeAt(i);
                // Send 8 bits (MSB first)
                for(let b=7; b>=0; b--) {
                    const bit = (char >> b) & 1;
                    box.style.background = bit ? "#FFF" : "#000";
                    await sleep(BIT_TIME);
                }
            }

            // Reset
            box.style.background = "#000";
            box.innerText = "DONE";
        }

        const sleep = ms => new Promise(r => setTimeout(r, ms));


        // --- RECEIVER LOGIC ---
        let rxActive = false;
        const vid = document.getElementById('video');
        const cvs = document.createElement('canvas'); // hidden processor
        const ctx = cvs.getContext('2d', { willReadFrequently: true });
        
        const gCvs = document.getElementById('debug-graph');
        const gCtx = gCvs.getContext('2d');
        
        // Signal History
        let history = new Array(300).fill(0);
        let minLvl = 0, maxLvl = 255;
        
        // State Machine
        let state = "SEARCH"; // SEARCH -> PILOT_LOCK -> READING -> DONE
        let msg = "";
        let bits = "";
        let nextSampleTime = 0;

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                vid.srcObject = stream;
                // iOS Fix
                vid.onloadedmetadata = () => vid.play();
                document.getElementById('cam-btn').style.display = 'none';
                rxActive = true;
                loop();
            } catch(e) { alert("Cam Error: "+e); }
        }

        function loop() {
            if(!rxActive) return;
            
            // 1. READ LUMA (Brightness)
            cvs.width = 20; cvs.height = 20;
            ctx.drawImage(vid, vid.videoWidth/2-10, vid.videoHeight/2-10, 20, 20, 0, 0, 20, 20);
            const frame = ctx.getImageData(0,0,20,20).data;
            let sum = 0;
            // Average R, G, B for Luma (Solves the "Yellow" issue)
            for(let i=0; i<frame.length; i+=4) {
                sum += (frame[i] + frame[i+1] + frame[i+2]) / 3;
            }
            const luma = sum / (frame.length/4);

            // 2. UPDATE HISTORY & RANGES
            history.push(luma);
            history.shift();
            
            // Dynamic Ranging (Look at last 3 seconds of data)
            // We use this to draw the "Blue Line" (Threshold)
            const recent = history.slice(-150); // last ~3s approx
            const localMin = Math.min(...recent);
            const localMax = Math.max(...recent);
            // Midpoint threshold
            const thresh = (localMax + localMin) / 2;

            // 3. LOGIC
            const now = Date.now();
            const isHigh = luma > thresh;

            if (state === "SEARCH") {
                // Look for the PILOT TONE (Sustained High for > 500ms)
                // If we see High for a long time, we know transmission is starting
                if (isHigh) {
                    // Check if we have been high for a while? 
                    // Simpler: Just look for the DROP.
                    // If current is High, check previous values.
                    // Actually, simpler logic:
                    // Just wait for the Drop-to-Black while 'max' is high.
                    
                    // If Luma is very high (Pilot)
                    if (luma > 200) { 
                        state = "PILOT_LOCK"; 
                    }
                }
            }
            else if (state === "PILOT_LOCK") {
                // We are locked onto the White Pilot tone.
                // WAITING FOR THE DROP (Start Edge)
                if (!isHigh) { 
                    // Signal just dropped to LOW!
                    // This is T=0 of the START SYNC.
                    // The first actual data bit starts in BIT_TIME ms.
                    // We want to sample in the MIDDLE of that bit.
                    // So wait BIT_TIME + (BIT_TIME/2).
                    
                    state = "READING";
                    // Skip the 'Sync' bit (Black), jump to first data bit
                    nextSampleTime = now + BIT_TIME + (BIT_TIME/2);
                    
                    msg = "";
                    bits = "";
                    document.getElementById('rx-msg').innerText = "Receiving...";
                    document.getElementById('rx-msg').style.color = "#FFD60A";
                }
            }
            else if (state === "READING") {
                if (now >= nextSampleTime) {
                    nextSampleTime += BIT_TIME;
                    
                    // Read Bit
                    const bit = isHigh ? "1" : "0";
                    bits += bit;
                    
                    // Visual Debug
                    document.getElementById('binary-debug').innerText = bits.slice(-16); // Show last 16 bits

                    // Do we have a full byte (8 bits)?
                    if (bits.length % 8 === 0) {
                        const byteStr = bits.slice(-8);
                        const charCode = parseInt(byteStr, 2);
                        const char = String.fromCharCode(charCode);

                        if (char === "\x02") {
                            // STX - Start of Text (Hidden)
                            msg = ""; 
                        }
                        else if (char === "\x03") {
                            // ETX - End of Text
                            state = "DONE";
                            finish();
                        }
                        else {
                            msg += char;
                            document.getElementById('rx-msg').innerText = msg;
                        }
                    }
                }
                
                // Timeout Watchdog
                if (now > nextSampleTime + 2000) {
                    state = "SEARCH";
                    document.getElementById('rx-msg').innerText = "Signal Lost";
                    document.getElementById('rx-msg').style.color = "red";
                }
            }

            // 4. DRAW GRAPH
            drawGraph(luma, thresh, localMin, localMax);
            
            // Status UI
            document.getElementById('state-lbl').innerText = "STATE: " + state;
            document.getElementById('thresh-lbl').innerText = "LUMA: " + Math.round(luma);

            requestAnimationFrame(loop);
        }

        function finish() {
            document.getElementById('rx-msg').style.color = "#0f0";
            if (msg.startsWith("http")) {
                const btn = document.getElementById('link-btn');
                btn.href = msg;
                btn.style.display = "inline-block";
                btn.innerText = "OPEN: " + msg.substring(0, 15) + "...";
            }
            state = "SEARCH";
        }

        function drawGraph(curr, thresh, min, max) {
            gCtx.fillStyle = "#000";
            gCtx.fillRect(0,0,300,80);
            
            // Draw Signal
            gCtx.beginPath();
            gCtx.strokeStyle = "#0f0";
            gCtx.lineWidth = 2;
            for(let i=0; i<300; i++) {
                const y = 80 - (history[i] / 255 * 80);
                if(i==0) gCtx.moveTo(i,y); else gCtx.lineTo(i,y);
            }
            gCtx.stroke();

            // Draw Threshold (Blue Line)
            const threshY = 80 - (thresh / 255 * 80);
            gCtx.beginPath();
            gCtx.strokeStyle = "#00f";
            gCtx.lineWidth = 1;
            gCtx.moveTo(0, threshY);
            gCtx.lineTo(300, threshY);
            gCtx.stroke();
        }

    </script>
</body>
</html>
