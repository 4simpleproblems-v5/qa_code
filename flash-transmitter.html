<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Semaphore: Optical Link</title>
    <style>
        body {
            background-color: #000;
            color: #ff3333;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        h1 { margin: 10px 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }

        /* TAB SYSTEM */
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .tab-btn {
            background: #220000;
            border: 1px solid #ff3333;
            color: #ff3333;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }
        .tab-btn.active { background: #ff3333; color: #000; }

        .view { display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; }
        .view.active { display: flex; }

        /* TRANSMITTER UI */
        #flash-box {
            width: 100%;
            flex-grow: 1;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10rem;
            font-weight: bold;
            color: #000; /* Text hidden unless needed */
        }
        .tx-controls {
            padding: 20px;
            width: 100%;
            max-width: 400px;
            display: flex;
            gap: 10px;
        }
        input[type="text"] {
            background: #110000;
            border: 1px solid #550000;
            color: #ff3333;
            padding: 10px;
            flex-grow: 1;
            font-family: inherit;
            text-transform: uppercase;
        }
        button {
            background: #ff3333;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
        }

        /* RECEIVER UI */
        #cam-container {
            position: relative;
            width: 300px;
            height: 225px;
            border: 2px solid #330000;
            background: #111;
            margin-bottom: 10px;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6; /* Dim video so graph pops */
        }
        /* The graph overlay */
        #scope {
            width: 100%;
            height: 100px;
            background: #110000;
            border-top: 1px solid #550000;
            border-bottom: 1px solid #550000;
        }
        #rx-log {
            font-size: 1.5rem;
            margin-top: 10px;
            min-height: 1.5rem;
            color: #fff;
            text-shadow: 0 0 5px #ff3333;
        }
        #threshold-line {
            position: absolute;
            width: 100%;
            height: 1px;
            background: #00ff00;
            opacity: 0.5;
            top: 50%;
            pointer-events: none;
        }
        .info { font-size: 0.7rem; color: #666; margin-top: 5px; }

    </style>
</head>
<body>

    <h1>Project Semaphore</h1>
    
    <div class="tabs">
        <div class="tab-btn active" onclick="switchTab('tx')">Transmitter</div>
        <div class="tab-btn" onclick="switchTab('rx')">Receiver</div>
    </div>

    <div id="view-tx" class="view active">
        <div id="flash-box"></div>
        <div class="tx-controls">
            <input type="text" id="msgInput" placeholder="HELLO" maxlength="10">
            <button onclick="transmit()">SEND</button>
        </div>
        <div class="info">Set screen brightness to MAX for best range.</div>
    </div>

    <div id="view-rx" class="view">
        <div id="cam-container">
            <video id="video" autoplay playsinline muted></video>
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:rgba(0,255,0,0.5); font-size:2rem;">+</div>
        </div>
        
        <canvas id="scope" width="300" height="100"></canvas>
        <div class="info">Align crosshair with flashing screen. <br>Green line = Trigger Threshold</div>
        
        <div style="margin-top: 20px; color:#888;">DECODED:</div>
        <div id="rx-log">Waiting...</div>
        
        <button onclick="startCamera()" style="margin-top:20px; width:200px;">Start Camera</button>
    </div>

    <script>
        // --- CONFIG ---
        // Slower speed = More reliable for webcams (which run at 30-60fps)
        const BIT_DURATION = 150; // ms per bit (approx 6 bits per second)
        
        // --- TABS ---
        function switchTab(mode) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('view-' + mode).classList.add('active');
            event.target.classList.add('active');
        }

        // --- TRANSMITTER ---
        const flashBox = document.getElementById('flash-box');
        
        async function transmit() {
            const text = document.getElementById('msgInput').value.toUpperCase();
            if(!text) return;

            // Convert text to binary string
            let binaryStream = "";
            for (let i = 0; i < text.length; i++) {
                // Get ASCII binary, pad to 8 bits
                let bin = text.charCodeAt(i).toString(2).padStart(8, "0");
                // Add UART framing: Start(1) + Data + Stop(0)
                // Note: Usually UART Start is 0 and Stop is 1. 
                // Since our "Idle" is Black (0), we will invert this logic for optics.
                // Idle: Black (0)
                // Start Bit: Red (1) (Wakes up receiver)
                // Data: ...
                // Stop Bit: Black (0) (Returns to idle)
                binaryStream += "1" + bin + "0"; 
            }

            // Play the stream
            for (let i = 0; i < binaryStream.length; i++) {
                const bit = binaryStream[i];
                setColor(bit === "1");
                await sleep(BIT_DURATION);
            }
            
            // Return to black
            setColor(false);
        }

        function setColor(isRed) {
            flashBox.style.backgroundColor = isRed ? "#ff0000" : "#000000";
        }

        const sleep = ms => new Promise(r => setTimeout(r, ms));


        // --- RECEIVER ---
        const video = document.getElementById('video');
        const canvas = document.createElement('canvas'); // hidden canvas to read pixels
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const scopeCanvas = document.getElementById('scope');
        const scopeCtx = scopeCanvas.getContext('2d');
        const rxLog = document.getElementById('rx-log');

        let isScanning = false;
        let brightnessHistory = new Array(300).fill(0);
        let threshold = 50; // Dynamic threshold based on average

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", frameRate: { ideal: 30 } } 
                });
                video.srcObject = stream;
                isScanning = true;
                requestAnimationFrame(scanLoop);
                document.querySelector('#view-rx button').style.display = 'none';
                rxLog.innerText = "";
            } catch (err) {
                alert("Camera error: " + err.message);
            }
        }

        // UART DECODER STATE MACHINE
        let rxState = "IDLE";
        let bitBuffer = "";
        let stateTimer = 0;

        function scanLoop() {
            if (!isScanning) return;

            // 1. READ BRIGHTNESS
            // Draw center of video to canvas
            canvas.width = 50; canvas.height = 50;
            // Draw only the center crop
            ctx.drawImage(video, video.videoWidth/2 - 25, video.videoHeight/2 - 25, 50, 50, 0, 0, 50, 50);
            
            const frame = ctx.getImageData(0, 0, 50, 50);
            let total = 0;
            // Calculate average brightness (Red channel heavy)
            for (let i = 0; i < frame.data.length; i += 4) {
                total += frame.data[i]; // Red channel
            }
            const brightness = total / (frame.data.length / 4);

            // 2. DRAW SCOPE (Visual Debugger)
            brightnessHistory.push(brightness);
            brightnessHistory.shift();
            drawScope();

            // 3. DETECT HIGH/LOW
            // Auto-exposure makes absolute numbers unreliable. 
            // We use a rolling dynamic threshold.
            const avgLevel = brightnessHistory.reduce((a,b)=>a+b) / brightnessHistory.length;
            const dynamicThresh = avgLevel + 10; // Must be significantly above average
            const isHigh = brightness > dynamicThresh;

            // 4. DECODE LOGIC (Sampling)
            const now = Date.now();
            
            if (rxState === "IDLE") {
                if (isHigh) {
                    // Start Bit Detected!
                    rxState = "READING";
                    bitBuffer = "";
                    // Wait 1.5 bit durations to sample the CENTER of the first data bit
                    stateTimer = now + (BIT_DURATION * 1.5); 
                }
            } else if (rxState === "READING") {
                if (now >= stateTimer) {
                    // Sample the bit
                    bitBuffer += isHigh ? "1" : "0";
                    
                    // Schedule next sample
                    stateTimer += BIT_DURATION;

                    // If we have 8 bits, decode char
                    if (bitBuffer.length === 8) {
                        const charCode = parseInt(bitBuffer, 2);
                        const char = String.fromCharCode(charCode);
                        rxLog.innerText += char;
                        
                        // Look for Stop Bit (should be next)
                        rxState = "STOP"; 
                    }
                }
            } else if (rxState === "STOP") {
                if (now >= stateTimer) {
                    // Stop bit passed, go back to idle
                    rxState = "IDLE";
                }
            }

            requestAnimationFrame(scanLoop);
        }

        function drawScope() {
            scopeCtx.fillStyle = "#110000";
            scopeCtx.fillRect(0, 0, 300, 100);
            
            scopeCtx.beginPath();
            scopeCtx.strokeStyle = "#ff3333";
            scopeCtx.lineWidth = 2;

            const max = 255;
            for (let i = 0; i < 300; i++) {
                const y = 100 - (brightnessHistory[i] / max * 100);
                if (i===0) scopeCtx.moveTo(i, y);
                else scopeCtx.lineTo(i, y);
            }
            scopeCtx.stroke();
        }

    </script>
</body>
</html>
