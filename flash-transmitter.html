<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PixelStream v2: Sparse Matrix</title>
    <style>
        :root { --bg: #111; --panel: #1e1e1e; --accent: #32D74B; --text: #eee; }
        body {
            background-color: var(--bg); color: var(--text);
            font-family: 'Courier New', monospace; margin: 0;
            display: flex; flex-direction: column; height: 100vh;
            overflow: hidden; -webkit-user-select: none;
        }

        /* NAVIGATION */
        .nav { display: flex; height: 50px; border-bottom: 1px solid #333; }
        .nav-item {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #222; cursor: pointer; font-weight: bold; border-right: 1px solid #333;
        }
        .nav-item.active { background: var(--accent); color: #000; }

        .view { display: none; flex: 1; flex-direction: column; align-items: center; padding: 10px; overflow-y: auto; }
        .view.active { display: flex; }

        /* EDITOR */
        .grid-container {
            display: grid; grid-template-columns: repeat(32, 1fr);
            width: 300px; height: 300px; border: 1px solid #555; background: #000;
            touch-action: none; image-rendering: pixelated;
        }
        .pixel { background: #000; }
        .pixel.on { background: #fff; }

        #tx-flash {
            width: 300px; height: 300px; background: #000; border: 4px solid #fff;
            display: none; align-items: center; justify-content: center;
            font-size: 2rem; font-weight: bold; color: #000;
            position: absolute; top: 10px; z-index: 100;
        }
        #tx-flash.active { display: flex; }

        .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; width: 300px; }
        button {
            flex: 1; padding: 12px; border: none; border-radius: 8px; min-width: 80px;
            font-weight: bold; cursor: pointer; background: #333; color: #fff;
        }
        button.primary { background: var(--accent); color: #000; flex-basis: 100%; }
        
        input[type="file"] { display: none; }
        .file-btn { background: #0A84FF; color: #fff; }

        /* RECEIVER */
        #cam-box {
            position: relative; width: 300px; height: 250px;
            background: #000; border: 2px solid #555; overflow: hidden; margin-bottom: 10px;
        }
        video { width: 100%; height: 100%; object-fit: cover; filter: grayscale(1) contrast(1.2); }
        
        #rx-canvas { width: 300px; height: 300px; background: #000; border: 1px solid #444; image-rendering: pixelated; }
        .status-bar { width: 300px; display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        #graph { width: 300px; height: 30px; background: #222; margin-top: 5px; }

    </style>
</head>
<body>

    <div class="nav">
        <div class="nav-item active" onclick="setView('tx')">SEND</div>
        <div class="nav-item" onclick="setView('rx')">RECEIVE</div>
    </div>

    <div id="tx-view" class="view active">
        <div id="tx-flash"></div>
        
        <div class="status-bar">
            <span id="pixel-count">0 White Pixels</span>
            <span id="compress-stat" style="color:var(--accent)">0s est</span>
        </div>

        <div class="grid-container" id="grid"></div>

        <div class="controls">
            <button onclick="clearGrid()">Clear</button>
            <button class="file-btn" onclick="document.getElementById('file-in').click()">Upload Img</button>
            <button class="primary" onclick="transmitImage()">TRANSMIT (SPARSE)</button>
        </div>
        <input type="file" id="file-in" accept="image/*" onchange="handleImageUpload(this)">
    </div>

    <div id="rx-view" class="view">
        <button id="start-cam" class="primary" style="width:300px; margin-bottom:10px;" onclick="startRx()">START CAMERA</button>
        
        <div id="cam-box">
            <video id="video" autoplay playsinline muted></video>
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:30px; height:30px; border:2px solid #0f0; box-shadow:0 0 0 100px rgba(0,0,0,0.85);"></div>
        </div>

        <div class="status-bar">
            <span id="rx-status">Idle</span>
            <span id="rx-progress">0%</span>
        </div>

        <canvas id="rx-canvas" width="32" height="32"></canvas>
        <canvas id="graph" width="300" height="30"></canvas>
    </div>

    <script>
        // --- CONFIG ---
        const BIT_MS = 60; // Speed of transmission
        const RES = 32;    // Resolution

        // --- NAVIGATION ---
        function setView(v) {
            document.querySelectorAll('.view').forEach(e => e.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(e => e.classList.remove('active'));
            document.getElementById(v+'-view').classList.add('active');
            event.target.classList.add('active');
        }

        // --- EDITOR LOGIC ---
        const grid = document.getElementById('grid');
        let pixels = new Array(RES * RES).fill(0); 

        // Init Grid
        for(let i=0; i<RES*RES; i++) {
            const div = document.createElement('div');
            div.className = 'pixel';
            grid.appendChild(div);
        }

        // Render from array
        function renderGrid() {
            pixels.forEach((p, i) => {
                grid.children[i].className = p ? 'pixel on' : 'pixel';
            });
            updateStats();
        }

        // --- IMAGE UPLOAD ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            const img = new Image();
            img.onload = () => {
                // Resize and Threshold
                const c = document.createElement('canvas');
                c.width = RES; c.height = RES;
                const ctx = c.getContext('2d');
                ctx.fillStyle = "#000"; ctx.fillRect(0,0,RES,RES);
                // Draw image scaled to 32x32
                ctx.drawImage(img, 0, 0, RES, RES);
                const data = ctx.getImageData(0,0,RES,RES).data;
                
                // Convert to Monochrome
                for(let i=0; i<RES*RES; i++) {
                    const r = data[i*4];
                    const g = data[i*4+1];
                    const b = data[i*4+2];
                    const luma = 0.299*r + 0.587*g + 0.114*b;
                    pixels[i] = luma > 100 ? 1 : 0; // Threshold
                }
                renderGrid();
            };
            img.src = URL.createObjectURL(file);
        }

        function clearGrid() { pixels.fill(0); renderGrid(); }

        // --- SPARSE MATRIX PROTOCOL ---
        // Protocol: "Delta Cursor"
        // We only tell the receiver where the WHITE pixels are relative to the last one.
        // NIBBLES (4 bits):
        // 0-14: Advance Cursor by (Value+1) and Draw White.
        // 15:   Advance Cursor by 15 and Draw NOTHING (Skip).
        function encodeSparse() {
            let bits = "";
            let cursor = -1;
            let whiteCount = 0;

            // Find next white pixel
            for(let i=0; i<pixels.length; i++) {
                if(pixels[i] === 1) {
                    let delta = i - cursor;
                    
                    // While distance is too big for one nibble (max 15 jump)
                    while(delta > 15) {
                        bits += "1111"; // Send '15' (Skip 15)
                        delta -= 15;
                    }

                    // Now delta is 1-15.
                    // We map 1->0000, 15->1110 (Value = Delta-1)
                    // Wait, we need 0-14 mapping.
                    // Delta 1 = Code 0. Delta 15 = Code 14.
                    const code = (delta - 1).toString(2).padStart(4, "0");
                    bits += code;

                    cursor = i;
                    whiteCount++;
                }
            }
            
            // End of transmission: Send a specific sequence or just stop?
            // We'll rely on Pilot tone stopping.
            return { bits, whiteCount };
        }

        function updateStats() {
            const data = encodeSparse();
            const time = Math.ceil((data.bits.length * BIT_MS) / 1000) + 2; // +2 for sync
            document.getElementById('pixel-count').innerText = data.whiteCount + " White Px";
            document.getElementById('compress-stat').innerText = "~" + time + "s";
        }

        // --- TRANSMITTER ---
        const flashBox = document.getElementById('tx-flash');
        
        async function transmitImage() {
            const { bits } = encodeSparse();
            flashBox.className = 'active';
            
            // 1. PILOT (Solid White - Sync)
            flashBox.style.background = '#FFF';
            flashBox.innerText = "PILOT";
            await wait(1500);

            // 2. START EDGE (Black)
            flashBox.style.background = '#000';
            flashBox.innerText = "";
            await wait(BIT_MS * 2);

            // 3. DATA
            for(let i=0; i<bits.length; i++) {
                flashBox.style.background = bits[i] === "1" ? "#FFF" : "#000";
                await wait(BIT_MS);
            }

            flashBox.style.background = "#000";
            flashBox.className = '';
        }
        const wait = ms => new Promise(r => setTimeout(r, ms));


        // --- RECEIVER ---
        let rxRunning = false;
        const vid = document.getElementById('video');
        const cvs = document.createElement('canvas');
        const ctx = cvs.getContext('2d', { willReadFrequently: true });
        
        const rxCtx = document.getElementById('rx-canvas').getContext('2d');
        const rxStat = document.getElementById('rx-status');
        const gCtx = document.getElementById('graph').getContext('2d');

        let history = [];
        let state = "SEARCH";
        let nextSample = 0;
        let nibbleBuf = "";
        let cursor = -1;

        async function startRx() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                vid.srcObject = stream;
                vid.onloadedmetadata = () => vid.play();
                document.getElementById('start-cam').style.display = 'none';
                rxRunning = true;
                
                // Clear to Black (This fills the "empty spaces" automatically)
                rxCtx.fillStyle = "#000";
                rxCtx.fillRect(0,0,32,32);
                
                loop();
            } catch(e) { alert(e); }
        }

        function loop() {
            if(!rxRunning) return;

            // 1. Luma
            cvs.width=20; cvs.height=20;
            ctx.drawImage(vid, vid.videoWidth/2-10, vid.videoHeight/2-10, 20, 20, 0, 0, 20, 20);
            const d = ctx.getImageData(0,0,20,20).data;
            let sum = 0;
            for(let i=0; i<d.length; i+=4) sum += (d[i]+d[i+1]+d[i+2])/3;
            const luma = sum / (d.length/4);

            // 2. Adaptive Threshold
            history.push(luma);
            if(history.length > 50) history.shift();
            const min = Math.min(...history);
            const max = Math.max(...history);
            const thresh = (min + max) / 2;
            const isHigh = luma > thresh;

            const now = Date.now();

            if(state === "SEARCH") {
                rxStat.innerText = "Waiting for Pilot...";
                // Lock Pilot
                if(luma > 200 && (max-min) < 60) {
                     // Wait for drop
                }
                // Check Drop
                if(isHigh && (max-min) > 50) state = "PILOT";
            }
            else if(state === "PILOT") {
                rxStat.innerText = "LOCKED";
                rxStat.style.color = "#FFF";
                if(!isHigh) {
                    state = "READ";
                    nextSample = now + (BIT_MS * 1.5); // Align to first bit center
                    nibbleBuf = "";
                    cursor = -1;
                    rxCtx.fillStyle = "#222"; rxCtx.fillRect(0,0,32,32); // Reset
                    rxStat.innerText = "RECEIVING...";
                    rxStat.style.color = "#32D74B";
                }
            }
            else if(state === "READ") {
                if(now >= nextSample) {
                    nextSample += BIT_MS;
                    nibbleBuf += isHigh ? "1" : "0";

                    if(nibbleBuf.length === 4) {
                        processNibble(nibbleBuf);
                        nibbleBuf = "";
                    }
                }
                if(now > nextSample + 2000) {
                    state = "SEARCH";
                    rxStat.innerText = "COMPLETE";
                    rxStat.style.color = "#888";
                }
            }

            // Graph
            gCtx.fillStyle="#222"; gCtx.fillRect(0,0,300,30);
            const h=30; 
            gCtx.fillStyle="#0f0"; gCtx.fillRect(150, h-(luma/255)*h, 4, 4);
            gCtx.fillStyle="blue"; gCtx.fillRect(0, h-(thresh/255)*h, 300, 1);
            
            requestAnimationFrame(loop);
        }

        function processNibble(bits) {
            const val = parseInt(bits, 2);
            
            if(val === 15) {
                // SKIP Command: Just move cursor, draw nothing
                cursor += 15;
            } else {
                // PAINT Command: Move (val+1), then draw
                const jump = val + 1;
                cursor += jump;
                drawPixel(cursor);
            }
        }

        function drawPixel(idx) {
            if(idx >= 1024) return;
            const x = idx % 32;
            const y = Math.floor(idx / 32);
            rxCtx.fillStyle = "#FFF";
            rxCtx.fillRect(x, y, 1, 1);
        }
    </script>
</body>
</html>
